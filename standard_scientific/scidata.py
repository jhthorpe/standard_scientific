# scidata.py 
#
# Contains the SciData class and associated functions which help in the
# creation and manipulation of scientific data. The key difference here
# are the explicit use of significant figures and supporting measures
# of uncertainty. 
#
# Revision History:
#   April 2, 2025 : JHT created
#

#imports from within this package
from standard_scientific.sigfig import eps
from standard_scientific.sigfig import SigFig 

#external imports
import functools
from dataclasses import dataclass
import numpy as np
import re

#################################################################################
# SciData 
#
# Class designed to help manage data in scientific notation, including 
# sig figs and uncertainties.
#
# NOTE: It is HIGHLY RECOMMENDED that you use the "from_SigFigs" or "from_str"
#       constructors rather than the constructors generated by the @dataclass
#       decorator, as these will NOT perform the correctness checking routines
#       supported by the other functions.
#
#       Additionally, the "from_SigFigs" constructor does NOT check that the
#       relative uncertainty (when given) is equal to the uncertainty divided by 
#       the value, as the relative uncertainty may be sensitive to numerical
#       errors in the rounding in SigFig.  
#
@functools.total_ordering
@dataclass
class SciData:
    '''Class for representing values and uncertaintines in scientific notation'''
    value: SigFig
    unc: SigFig
    rel_unc: SigFig
    is_exact: bool

    # Note, default initialization will come from dataclass decorator and will NOT
    # perform any correctness checking.

    ##########################
    # from_str
    # 
    # Generates values in scientific notatoin from a string
    #
    # Here is the most general case(s):
    #   12.345(67) x 10-23
    #   "12.345[[(67)] [x10[-]23]]"
    #  
    # This classmethod is specifically intended to be useful in parsing 
    # text data from online sources (such as CODATA, IUPAC, etc.)
    #
    # NOTE: 
    #   There are many many more ways that you can format this string
    #   badly than there are to do it correctly. Rather than protect 
    #   against ALL of them, we will simply trust that the number of ways to 
    #   format this correctly *that python will accept as a valid conversion 
    #   to floating point numbers* is relatively slim
    #
    @classmethod
    def from_str(cls, s):
        val = None
        unc = None
        rel = None
        exact = False

        #characters that indicate the start of the exponent section 
        #after removal of whitespace
        #
        # NOTE: annoyingly, it MATTERS that x10** and x10^ is searched *before*
        #       x10, because x10 is a substring of both and we need to extract it
        exponent_strings = ["e", "E", "x10**", "x10^", "x10"]

        s_in = s
        print(f"At start : {s}")#TESTING

        #start by trimming whitespace
        s = "".join(s.split()) 
        print(f"After trim : {s}") #TESTING

        #Now, if we have an exponent section, extract it. 
        #NOTE, this *intentionally* keeps badly formated strings with multiple
        #      matches which will fail upon float conversion (and need to be caught) 
        s_pow = "0" #default exponent power 
        s_exp = 1. #default exponent
        for sub in exponent_strings:
            if sub in s:
                s, s_pow = s.split(sub)
                break
        try:
            s_pow = int(s_pow) #important INT conversion to handle things like 8.9
            s_exp = pow(10., s_pow)
        except Exception as e:
            assert(False), f"Exception was thrown while attempting to extract exponent of {s_in}. {e}"
        print(f"Pre and post exponents are {s} and {s_pow} // {s_exp}") #TESTING

        #Exponent is dealt with, now to extract uncertainties if they are there 
        # NOTE: the correct uncertainties will map from a string started with ( and ending with )
        #       and will contain ONLY digits between these strings. We implicitly check for this
        #       behavior by conversion to int. This int is then converted to a float by 
        #       finding the decimal places remaining in the string before (, which the 
        #       uncertainty "replaces". That is, the string
        #       1.23(45) encodes a value of 1.23 and an uncertainty of (0.45).
        #
        #       NOTE that in this case there should be no leading zeros, buuuut if there are then
        #       we can just accept them and convert as would be intended (treating those zeros
        #       as significant and using their number to move the decimal) 
        unc_sfig = None
        if ("(" in s and ")" in s):
            s, s_unc = s.split("(")
            s_unc, s_tmp = s_unc.split(")")

            excact = False

            print(f"value {s} and uncertainty {s_unc} after extraction!") #TESTING

            #extract number of sig figs in the uncertainty
            unc_sfig = len(s_unc)

            #extract location of the uncertainty in the value
            assert(False), f"JHT has not coded past here!!! THIS IS WHERE TO WORK NEXT" 

            #Convert to int, then to actual value

        #if nothing is found, then 
        else:
            exact = True


        # Determine the number of significant figures in the value itself
        #
        # Rules
        #
        value_sfig = None
        assert(False), f"JHT has not coded past here!!! Need to handle uncertainty sig figs first"


        # Now convert the value at last
        try:
            value = float(s) * s_exp
            print(f"Extracted value was {value}")

        except Exception as e:
            assert(False), f"Exception was thrown while attempting to extract value and relative uncertainty of {s_in}. {e}"

        #convert to sigfigs at end, and form relative uncertainty
        value_SigFig = SigFig.from_float(value = value, sigfigs = value_sfig)
        unc_SigFig = SigFig.from_float(value = unc, sigfigs = unc_sfig) if not exact else None 
        rel_SigFig = unc_SigFig / value_SigFig if not exact else None

        return SciData(value = value_SigFig, unc = unc_SigFig, rel_unc = rel_SigFig, is_exact = exact) 


    ##########################
    # from_SigFigs 
    #
    # Generate the class from SigFig classes. There are 
    # four cases:
    # 
    # 1) The value is exact and there is no uncertainty
    #       -> Create exact SciData 
    # 2a) The data is inexact but rel_unc and unc are both given 
    #       -> Store data. NOTE, we do NOT check that rel_unc ==
    #          value / unc (with sigfigs) 
    # 2b) The data is inexact and rel_unc is not given
    #       -> Generate the relative uncertainty from the sig figs 
    # 2c) We are not given the uncertainty at all and we are not exact
    #       -> This must error!
    #
    # NOTE: given the floating point numerical issues of uncertainties near cutoffs between 
    #       SigFig classes, we do not STRICTLY require that the relative uncertainty be rigerously
    #       identical to the uncertainty divided by the value. 
    #
    @classmethod
    def from_SigFigs(cls, value: SigFig, unc: SigFig, rel_unc: SigFig, is_exact=False):

        #in case of non-exact data 
        if not is_exact:

            assert(isinstance(value, SigFig)), f"{value} was not an instance of scientific_notation:SigFig ."
            assert(isinstance(unc,   SigFig)), f"{unc} was not an instance of scientific_notation:SigFig ."
            assert(isinstance(rel_unc, SigFig) or 
                   rel_unc is None), f"{rel_unc} was not an instance of scientific_notation:SigFig or None."

            # We have a relative uncertainty
            if not rel_unc is None:
                return SciData(value = value, unc = unc, rel_unc = rel_unc, is_exact = False) 

            # We do NOT have a relative uncertainty, use SigFig division
            else:
                return SciData(value = value, unc = unc, rel_unc = unc / value, is_exact = False) 

        #in case of exact data
        else:
            assert(isinstance(value, SigFig)), f"{value} was not an instance of scientific_notation:SigFig ."
            return SciData(value = value, unc = None, rel_unc = None, is_exact = True) 




    ##########################
    # .json inferfaces
    #To dict

    #from Dict

    
    ##########################
    # Add, substract
    #
    # Note that there are TWO versions of this function, 
    #
    # Note that the uncertainty propogation 
    # in this case defaults to the "no covariance" case, 
    # which is not correct but is what I imagine most 
    # users would want.
    
    
    ##########################
    # Mult. Div. 
    # 
    # default: with covariance value 
    #
    # no_covar: no covariance value 
    

    ##########################
    # __eq__ comparison
    #
    # This is the strict comparison of objects, 
    # not the statistical version that should be used
    # in scientific litt. Note that these comparisions will 
    # be SigFig comparisions!
    #
    def __eq__(self, other):
        if (isinstance(other, SciData)):
            if (not self.is_exact and not other.is_exact):
                return (self.value == other.value and
                     self.unc == other.unc and
                     self.rel_unc == other.rel_unc and
                     self.is_exact == other.is_exact)
            elif (self.is_exact and other.is_exact):
                return (self.value == other.value)
            return False
        else:
            return self.value == other
     

    ##########################
    # __lt__ comparison
    #
    # This tests strict lt comparison of the values, not the
    # statistical probability that should be used in scientific
    # litt.
    #
    def __lt__(self, other):
        if (isinstance(other, SciData)):
            return (self.value < other.value)
        else:
            return (self.value < other)

